#!/usr/bin/perl
use warnings;
use strict;
use File::Basename qw|dirname basename|;
use List::Util qw(min max);
use POSIX qw(ceil);
use JSON::XS;

my @files;

my $wwan_path = dirname(__FILE__)."/../../../package/network/utils/wwan/files/data/";
opendir D, $wwan_path or die "opendir($wwan_path): $!";
@files = (@files, grep { -f $_ } map { "$wwan_path/$_" } readdir D);
closedir D;

my $local_path = dirname(__FILE__)."/data/";
opendir D, $local_path or die "opendir($local_path): $!";
@files = (@files, grep { -f $_ } map { "$local_path/$_" } readdir D);
closedir D;

@files = sort { basename($a) cmp basename($b) } @files;

my @rows;
for my $file (@files) {
	my ($vid, $pid) = split(/-/, basename($file));
	
	open (F, "<$file") or die("open($file): $!");
	my $raw_json = "";
	while (!eof(F)) {
		read(F, my $buf, 4096);
		$raw_json .= $buf;
	}
	close F;
	
	$raw_json =~ s/,\s*([\}\]])/$1/g;
	
	my $json = JSON::XS->new->decode($raw_json);
	
	my $type = uc($json->{mode} || $json->{type} || "ppp");
	my $net = uc($json->{net} || "gsm");
	
	next if ($type eq 'QMI' || $type eq 'MBIM');
	
	if ($type eq 'NCM') {
		$json->{control} = 0 if !exists $json->{control};
		$json->{data} = 0 if !exists $json->{data};
	}
	
	push @rows, [
		sprintf("0x%04x", hex $vid).",",
		sprintf("0x%04x", hex $pid).",",
		"\"".$json->{desc}."\",",
		"UsbDiscover::TYPE_$type,",
		"UsbDiscover::NET_$net,",
		(exists $json->{control} ? $json->{control} : 0xFF).",",
		(exists $json->{data} ? $json->{data} : 0xFF)
	];
}

push @rows, ["0,", "0,", "\"\",", "UsbDiscover::TYPE_UNKNOWN,", "UsbDiscover::NET_GSM,", "0,", "0"];

open(F, ">".dirname(__FILE__)."/src/UsbDiscoverData.cpp");
print F "#include \"UsbDiscover.h\"\n\n";
print F "/* DO NOT EDIT! THIS FILE GENERATED BY gen-modems-index.pl */\n";
print F "const std::vector<UsbDiscover::ModemDescr> UsbDiscover::m_modem_list = {\n";
print F printTable(\@rows, "\t{", "},");
print F "};\n";
close F;

sub printTable {
	my ($table, $before, $after) = @_;
	
	my $out = '';
	
	my $max_col_width = {};
	
	for my $row (@$table) {
		my $col_n = 0;
		
		if (ref($row) eq 'ARRAY') {
			for (my $col_n = 0; $col_n < scalar(@$row); $col_n++) {
				my $col = $row->[$col_n];
				$col = ($before || "").$col if $col_n == 0;
				$col = $col.($after || "") if $col_n == scalar(@$row) - 1;
				$max_col_width->{$col_n} = max($max_col_width->{$col_n} || 0, countSymbols($col));
				$row->[$col_n] = $col;
			}
		}
	}
	
	my $tab_size = 4;
	
	for my $row (@$table) {
		my $col_n = 0;
		if (ref($row) eq 'ARRAY') {
			for my $col (@$row) {
				my $max_width = ceil(($max_col_width->{$col_n} + 1) / $tab_size);
				my $cur_width = ceil(countSymbols($col) / $tab_size);
				
				my $need_tabs = ($max_width - $cur_width);
				$need_tabs++ if (countSymbols($col) % $tab_size != 0);
				
				$out .= $col.("\t" x $need_tabs);
				
				$col_n++;
			}
		} else {
			$out .= $row;
		}
		$out .= "\n";
	}
	
	$out =~ s/[ \t]+$//gm;
	
	return $out;
}

sub countSymbols {
	my ($str) = @_;
	$str = "$str";
	$str =~ s/\t/..../g;
	return length($str);
}
